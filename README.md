# PrairieGrader

An service that executes PrairieLearn external grading jobs.

## How it works

PrairieGrader uses a queue (SQS, RabbitMq), a file store (S3, disk), and
webhooks to communicate with PrairieLearn. The queue holds pending jobs; each
instance of PrairieGrader can poll the queue to receive new jobs to execute.
The file store holds the files from PrairieLearn (student files, tests, etc),
the results of the grading job (both `results.json` and an archive of the
contents of the `/grade` directory), and any logs generated by the job. The
webhook is used to communicate job status back to PrairieLearn. Currently,
this includes an acknowledgement that the job was received and a notification
when it has been completely graded.

Both the queue and file store sit behind a layer of abstraction so that an
implementation appropriate for the current environment can be used. For
example, in production, we want to use SQS as the queue and S3 as the file
store, since we have AWS services available to us. However, when running a
local development environment, AWS will be unavailable for most people. In
that case, we'll use RabbitMq for the queue and disk for the file store. By
making external dependencies like AWS optional, we enable an easy local
development experience.

If you'd like to add a different queue or file store, see `lib/queue` and
`lib/fileStore`, respectively.

## Running PrairieGrader locally

The recommended way to run PrairieGrader locally is to use Docker Compose. This
will give you a Postgres database, RabbitMq queue, and appropriate volumes to
transfer data between PrairieGrader and your local copy of PrairieLearn. The
`docker-compose.yml` file in the PrairieLearn repository will configure
everything correctly.

For an explanation of how this actually works, read on!

When running in Docker Compose, both PrairieGrader and PrairieLearn are running
as Docker containers. They use a Docker volume as a shared space to send files
back and forth. This introduces a unique challenge: we need to be able to get
those files to a sister container that we'll spin up for each grading job.
Since that container isn't known when `docker-compuse up` is run, we can't
make that container part of the Docker Compose configuration. We get around
this by mounting the Docker socket (`/var/run/docker.sock`) into the
PrairieGrader container. This allows PrairieGrader to control the Docker
daemon on the host machine, which gives it the ability to run the sister
container that's necessary for grading. Files are sent between PrairieGrader
and that sister container with another volume that's mounted to `/jobs` in
the grading container.

You can look at the `docker-compose.yml` file in PrairieLearn and the
configuration file in `config/local-docker.yaml` in this repository for more
information.

## Running PrairieGrader in production

In production, SQS is used for the queue and S3 is used as the file store.
Additionally, we send all logs to CloudWatch for archiving.

## Configuring PrairieGrader

PrairieGrader is configured with a combination of config files and environment
variables. The config files are used to provide sensible default based on the
environment (development, local Docker stack, production, etc). Environment
variables are used to optionally override the defaults set in the config files
or to provide passwords, secrets, or URLs that shouldn't be committed in this
repo.

Config files are written as a YAML file, with each key specifying a config
option with a default and optionally an environment variable to use to override
that key. Consider the following simple config file:

```yaml
properties:
  useDatabase:
    default: true
    envVar: USE_DATABASE
```

The resulting config would have a single property `useDatabase` that defaults
to `true` but can be overridden by setting the `USE_DATABASE` environment
variable when running PrairieGrader.

Configs files can use a simple form of inheritance to avoid repeating properties
that have defaults shared between environments. Inheritance is specified with
the `parent` property. Defaults are taken from the most specific config file,
with more specific config files overriding their parents. For instance, take the
following two files:

`base.yaml`
```yaml
properties:
  useDatabase:
    default: true
    envVar: USE_DATABASE
  queueType:
    default: 'rabbitmq'
    envVar: QUEUE_TYPE
```

`dev.yaml`
```yaml
parent: base
properties:
  useDatabase:
    default: false
```

If the `dev.yaml` config file is being used, then `queueType` will still default
to `rabbitmq` since it's specified as such in `base.yaml`, but `useDatabase`
will default to false. Note that even though `dev.yaml` did not define `envVar`
for `useDatabase`, it can still be overridden with the `USE_DATABASE`
environment variable since that was defined in `base.yaml`.

The config file that's used is determined from the `NODE_ENV` environment
variable. For example, if `NODE_ENV=local-docker`, then the config file
`config/local-docker.yaml` will be used.

Like PrairieLearn, PrairieGrader will read AWS configuration from a `aws-config.json` file in the project root upon startup if it is present. Otherwise, it is assumed that AWS credentials can be obtained via [IAM Roles for EC2](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html).
